id: gorti
name: Gorti
description: >-
  An enhanced homomorphic cryptosystem originally designed by Gorti VNKV Subba 
  Rao and Dr. Garimella Uma for secure transmissions in MANETs (Mobile Ad-hoc 
  Networks). It relies on the large number factorisation problem to be secure.
bitLengths:
  - bitLength: 16
    maxInt: 100
  - bitLength: 8
    maxInt: 13
stages:
  - name: Key Generation
    location: client
    pre_description: >-
      This phase sets up the keys that are used in both encryption and 
      decryption.
    steps:
      - description: A random prime number
        compute: p = generateRandomPrime()
      - description: A random prime number
        compute: q = generateRandomPrime()
      - description: \(p \times q\)
        compute: m = p * q
    post_description: >-
      The original paper uses \(p\) as a shared key among clients in a MANET. 
      In this client-server model, we only have one client and so we only 
      have a Secret key consisting of \((p, q, m)\).

  - name: Encryption
    location: client
    pre_description: >-
       Next, we calculate \(aX\) and \(bX\) as our encrypted values of \(a\) 
       and \(b\).
    steps:
      - description: A random number
        compute: aR = generateRandomPrime()
      - description: \(a + aR \times p^q \bmod m\)
        compute: aX = (a + (aR * (p & q,m))) % m
        expose: true
      - description: A random number
        compute: bR = generateRandomPrime()
      - description: \(b + bR \times p^q \bmod m\)
        compute: bX = (b + (bR * (p & q,m))) % m
        expose: true
    post_description: >-
      \(aX\) and \(bX\) are one way as per the large number factorisation 
      problem. In practice we would use much larger key-spaces (1024+ bit) to 
      create a sufficiently hard enough problem.

  - name: "Backend: Multiplication"
    location: backend
    pre_description: >- 
      Any computer in the cloud can calculate the following without being able
      to learn the values of \(a\) or \(b\).
    steps:
      - description: \(aX \times bX\)
        compute: cX = aX * bX
    post_description: >- 
      The homomorphic property of this cryptosystem is \(D(aX \times bX) = a 
      \times b\) where \(D\) is the decryption algorithm.

  - name: "Backend: Addition"
    location: backend
    pre_description: >-
      Any computer in the cloud can calculate the following without being able 
      to learn the values of \(a\) or \(b\).
    steps:
      - description: \(aX + bX\)
        compute: cX = aX + bX
    post_description: >-
      The homomorphic property of this cryptosystem is \(D(aX + bX) = a + b\) 
      where \(D\) is the decryption algorithm.

  - name: Decryption
    location: client
    pre_description: >-
      Finally, using the decryption algorithm, we can get our answer for \(c\).
    steps:
      - description: \(cX \bmod p\)
        compute: c = cX % p
    post_description: >-
      We are able to decrypt the returned \(cX\) becase we know the value of 
      \(p\) from our Secret key (which would have been shared in a MANET).
