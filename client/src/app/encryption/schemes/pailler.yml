uniqueName: pailler
readableName: Pailler
description: The Pailler additive somewhat homomorphic encryption scheme
bitLengths:
  - bitLength: 8
    maxInt: 99
  - bitLength: 16
    maxInt: 9999
stages:
  setup:
    - name: Key Generation
      preDescription:
      steps:
        - description: A random prime number
          compute: p = generateRandomPrime()
        - description: A random prime number
          compute: q = generateRandomPrime()
        - description: \(p \times q\)
          compute: n = p * q
          expose: true
        - description: \(n + 1\)
          compute: g = n + 1
        - description: \(\phi(p \times q)\)
          compute: l = (p - 1) * (q - 1)
        - description: \(l^{-1} \bmod n\)
          compute: m = l $ n
      postDescription: The Public Key consists of \((n)\) and the Private Key consists of \((l, m)\)
  encryption:
    - name: Encryption
      preDescription:
      steps:
        - description: \(n^2\)
          compute: nSq = n * n
          expose: true
        - description: random number such that
          compute: aR = generateR(n)
        - description: \((g^a \times aR^n) \bmod n^2\)
          compute: aX = ((g & a,nSq) * (aR & n,nSq)) % nSq
          expose: true
        - description: random number such that
          compute: bR = generateR(n)
        - description: \((g^b \times bR^n) \bmod n^2\)
          compute: bX = ((g & b,nSq) * (bR & n,nSq)) % nSq
          expose: true
      postDescription:
  backend:
    +:
      name: Backend Addition
      steps:
        - description: \((aX \times bX) \bmod n^2\)
          compute: cX = (aX * bX) % nSq
  decryption:
    - name: Decryption
      steps:
        - description: \((\frac{(cX^l\bmod n^2) - 1}{n})\times cX \bmod n \)
          compute: c = ((((cX & l,nSq) - 1) / n) * m) % n
